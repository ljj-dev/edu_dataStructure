<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="../../resources/favicon.ico" th:href="@{/static/favicon.ico}"/>
    <script src="../../js/axios.js"></script>
    <script src="../../js/vue.js" charset="utf-8"></script>
    <script src="../../js/lib-master/index.js" charset="utf-8"></script>
    <link rel="stylesheet" href="../../js/lib-master/theme-chalk/index.css"/>
    <link rel="stylesheet" href="../../css/firstChapter.css"/>

</head>
<body>
<div id="app">
    <div class="homeWrap">
        <el-container>
            <el-header></el-header>
            <el-aside width="350px">
                <h5>绪论目录</h5>
                <el-menu
                        default-active="2"
                        class="el-menu-vertical-demo"
                        @open="handleOpen"
                        @close="handleClose"
                        active-text-color="#ffd04b">
                    <el-submenu index="1">
                        <template slot="title">
                            <span><a href="#first1-1">1.1 数据结构的研究内容</a></span>
                        </template>
                        <el-menu-item-group>
                            <el-menu-item index="1-1"><a href="#first1-1">1.1 数据结构的研究内容</a></el-menu-item>
                        </el-menu-item-group>
                    </el-submenu>
                    <el-submenu index="2">
                        <template slot="title">
                            <span><a href="#first1-2">1.2 基本概念和术语</a></span>
                        </template>
                        <el-menu-item-group>
                            <el-menu-item index="2-1"><a href="#first1-2-1">1.2.1 数据、数据元素、数据项和数据对象</a>
                            </el-menu-item>
                            <el-menu-item index="2-2"><a href="
                            #first1-2-2">1.2.2 数据结构</a></el-menu-item>
                            <el-menu-item index="2-3"><a href="#first1-2-3">1.2.3 数据类型和抽象数据类型</a></el-menu-item>
                        </el-menu-item-group>
                    </el-submenu>
                    <el-submenu index="3">
                        <template slot="title">
                            <span><a href="#first1-3">1.3 抽象数据类型的表示与实现</a></span>
                        </template>
                        <el-menu-item-group>
                            <el-menu-item index="3-1"><a href="#first1-3">1.3 抽象数据类型的表示与实现</a></el-menu-item>
                        </el-menu-item-group>
                    </el-submenu>
                    <el-submenu index="4">
                        <template slot="title">
                            <span><a href="#first1-4">1.4 算法和算法分析</a></span>
                        </template>
                        <el-menu-item-group>
                            <el-menu-item index="4-1"><a href="#first1-4-1">1.4.1 算法的定义及特性</a></el-menu-item>
                            <el-menu-item index="4-2"><a href="#first1-4-2">1.4.2 评价算法优劣的基本标准</a></el-menu-item>
                            <el-menu-item index="4-3"><a href="#first1-4-3">1.4.3 算法的时间复杂度</a></el-menu-item>
                            <el-menu-item index="4-4"><a href="#first1-4-4">1.4.4 算法的空间复杂度</a></el-menu-item>
                        </el-menu-item-group>
                    </el-submenu>
                    <el-submenu index="5">
                        <template slot="title">
                            <span><a href="#first1-5">1.1 数据结构的研究内容</a></span>
                        </template>
                        <el-menu-item-group>
                            <el-menu-item index="5-1"><a href="#first1-1">1.5 小结</a></el-menu-item>
                        </el-menu-item-group>
                    </el-submenu>
                </el-menu>
            </el-aside>

            <el-main>
                <!--第一节-->
                <div>
                    <div><span id="first1-1" style="font-size: xxx-large; font-weight: bold;">1.1 数据结构的研究内容</span>
                    </div>
                    <div>
                        计算机主要用于数值计算时，一般要经过如下几个步骤：首先从具体问题抽象出数学模型，然后设计一个解此数学模型的算法，最后编写程序，进行测试、调试，直到解决问题。在此过程中寻求数学模型的实质是分析问题，从中提取操作的对象，并找出这些操作对象之间的关系，然后用数学语言加以描述，即建立相应的数学方程。例如，用计算机进行全球天气预报时，就需要求解一组球面坐标系下的二阶椭圆偏微分方程；预测人口增长情况的数学模型为常微分方程。求解这些数学方程的算法是计算数学研究的范畴，如高斯消元法、差分法、有限元法等算法。数据结构主要研究非数值计算问题，非数值计算问题无法用数学方程建立数学模型，下面通过三个实例加以说明。
                    </div>
                    <div><strong>【例1.1】 </strong>
                        学生学籍管理系统。高等院校教务处使用计算机对全校的学生情况作统一管理。学生的基本信息，包括学生的学号、姓名、性别、籍贯、专业等，如表1.1所示。每个学生的基本情况按照不同的顺序号，依次存放在“学生基本信息表”中，根据需要对这张表进行查找。每个学生的基本信息记录按顺序号排列，形成了学生基本信息记录的线性序列，呈一种线性关系。
                    </div>
                    <div style="text-align: center;"><strong>表1.1 学生基本信息表</strong>
                    </div>
                    <div style="text-align: center;"><img src="../../images/biao1-1.png"
                                                          style="width: 550px; height: 150px">
                    </div>
                    <div>
                        诸如此类的线性表结构还有图书馆的书目管理系统、库存管理系统等。在这类问题中，计算机处理的对象是各种表，元素之间存在简单一对一的线性关系，因此这类问题的数学模型就是各种线性表，施加于对象上的操作有查找、插入和删除等。这类数学模型称为“线性”的数据结构。
                    </div>
                    <div><br/>
                    </div>
                    <div><strong>【例1.2】</strong>
                        人机对弈问题。计算机之所以能和人对弈是因为已经将对弈的策略在计算机中存储好。由于对弈的过程是在一定规则下随机进行的，所以，为使计算机能灵活对弈，就必须把对弈过程中所有可能发生的情况及相应的对策都加以考虑。以最简单的井字棋为例，初始状态是一个空的棋盘格局。对弈开始后，每下一步棋，则构成一个新的棋盘格局，且相对于上一个棋盘格局的可能选择可以有多种形式，因而整个对弈过程就如同图1.1所示的“一棵倒长的树”。在这棵“树”中，从初始状态（根）到某一最终格局（叶子）的一条路径，就是一次具体的对弈过程。
                    </div>
                    <div style="text-align: center;"><img src="../../images/tu1-1.png"
                                                          style="width: 350px; height: 720px"><br>
                    </div>
                    <div style="text-align: center;"><strong>图1.1 井字棋的对弈树</strong>
                    </div>
                    <div>
                        人机对弈问题的数学模型就是如何用树结构表示棋盘和棋子等，算法是博弈的规则和策略。诸如此类的树结构还有计算机的文件系统、一个单位的组织机构等。在这类问题中，计算机处理的对象是树结构，元素之间是一对多的层次关系，施加于对象上的操作有查找、插入和删除等。这类数学模型称为“树”的数据结构。
                    </div>
                    <div><br/>
                    </div>
                    <div><strong>【例1.3】</strong>
                        最短路径问题。从城市A到城市B有多条线路，但每条线路的交通费不同，那么，如何选择一条线路，使得从城市A到城市B的交通费用最少呢？解决的方法是，可以把这类问题抽象为图的最短路径问题。如图1.2所示，图中的顶点代表城市，有向边代表两个城市之间的通路，边上的权值代表两个城市之间的交通费。求解A到B的最少交通费用，就是要在有向图中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。
                    </div>
                    <div style="text-align: center;"><img src="../../images/tu1-2.png"
                                                          style="width: 400px; height: 300px">
                    </div>
                    <div style="text-align: center;"><strong>图1.2 最短路径问题</strong>
                    </div>
                    <div>
                        最短路径问题的数学模型就是图结构，算法是求解两点之间的最短路径。诸如此类的图结构还有网络工程图和网络通信图等，在这类问题中，元素之间是多对多的网状关系，施加于对象上的操作依然有查找、插入和删除等。这类数学模型称为“图”的数据结构。
                    </div>
                    <div><br/>
                    </div>
                    <div>
                        从上面三个实例可以看出，非数值计算问题的数学模型不再是数学方程，而是诸如线性表、树和图的数据结构。因此，简单地说，数据结构是一门研究非数值计算程序设计中的操作对象，以及这些对象之间的关系和操作的学科。
                    </div>
                    <div><br/>
                    </div>
                    <div>
                        20世纪60年代初期，“数据结构”有关的内容散见于操作系统、编译原理等课程中。1968年，“数据结构”作为一门独立的课程被列入美国一些大学计算机科学系的教学计划，同年，著名计算机科学家D.E.Knuth教授发表了《计算机程序设计艺术》第一卷《基本算法》。这是第一本较系统地阐述“数据结构”基本内容的著作。之后，随着大型程序和大规模文件系统的出现，结构化程序设计成为程序设计方法学的主要研究方向，人们普遍认为程序设计的实质就是对所处理的问题选择一种好的数据结构，并在此结构基础上施加一种好的算法，著名科学家Wirth教授的《算法+数据结构=程序》正是这种观点的集中体现。
                    </div>
                    <div><br/>
                    </div>
                    <div>
                        目前，数据结构在计算机科学中是一门综合性的专业基础课。数据结构的研究不仅涉及计算机硬件（特别是编码理论、存储装置和存取方法等）的研究范围，而且和计算机软件的研究有着密切的关系，无论是编译程序还是操作系统都涉及数据元素在存储器中的分配问题。在研究信息检索时也必须考虑如何组织数据，以使查找和存取数据元素更为方便。因此，可以认为数据结构是介于数学、计算机硬件和软件三者之间的一门核心课程。
                    </div>
                    <div><br/>
                    </div>
                    <div>有关“数据结构”的研究仍不断发展，一方面，面向各专门领域中特殊问题的数据结构正在研究和发展；另一方面，从抽象数据类型的观点来讨论数据结构，已成为一种新的趋势，越来越被人们所重视。
                    </div>
                </div>

                <!--第二节-->
                <div>
                    <div><span id="first1-2" style="font-size: xxx-large; font-weight: bold;">1.2 基本概念和术语</span>
                    </div>
                    <div>下列概念和术语将在以后各章节中多次出现，本节先对这些概念和术语赋予确定的含义。
                    </div>
                    <div><br/>
                    </div>
                    <div><span id="first1-2-1"
                               style="font-size: xx-large; font-weight: bold; ">1.2.1 数据、数据元素、数据项和数据对象</span>
                    </div>
                    <div><span style="font-weight: bold;">数据（Data）</span>是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。如数学计算中用到的整数和实数，文本编辑中用到的字符串，多媒体程序处理的图形、图像、声音及动画等通过特殊编码定义后的数据。
                    </div>
                    <div><span style="font-weight: bold;">数据元素（Data Element）</span>是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为元素、记录等。数据元素用于完整地描述一个对象，如前一节示例中的一名学生记录，树中棋盘的一个格局（状态），以及图中的一个顶点等。
                    </div>
                    <div><span style="font-weight: bold;">数据项（Data Item）</span>是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。
                    </div>
                    <div><span style="font-weight: bold;">数据对象（Data Object）</span>是性质相同的数据元素的集合，是数据的一个子集。例如：整数数据对象是集合N={0，±1，±2，…}，字母字符数据对象是集合C={‘A’，‘B’，…，‘Z’，‘a’，‘b’，…，‘z’}，学生基本信息表也可以是一个数据对象。由此可以看出，不论数据元素集合是无限集（如整数集），或是有限集（如字母字符集），还是由多个数据项组成的复合数据元素（如学生表）的集合，只要集合内元素的性质均相同，都可称之为一个数据对象。
                    </div>
                    <div><br/>
                    </div>
                    <div><span id="first1-2-2" style="font-size: xx-large; font-weight: bold; ">1.2.2 数据结构</span>
                    </div>
                    <div><span style="font-weight: bold;">数据结构（Data Structure）</span>是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。
                    </div>
                    <div>数据结构包括逻辑结构和存储结构两个层次。
                    </div>
                    <div><span style="font-weight: bold; font-size: x-large;">1．逻辑结构</span>
                    </div>
                    <div>
                        数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。数据的逻辑结构有两个要素：一是数据元素；二是关系。数据元素的含义如前所述，关系是指数据元素间的逻辑关系。根据数据元素之间关系的不同特性，通常有四类基本结构，如图1.3所示。它们的复杂程度依次递进。
                    </div>
                    <div style="text-align: center;"><img src="../../images/tu1-3.png"
                                                          style="width: 500px; height: 400px">
                    </div>
                    <div style="text-align: center;"><strong>图1.3 四类基本逻辑结构关系图</strong>
                    </div>
                    <div>下面四种结构中所举的示例是以某班级学生作为数据对象（数据元素是学生的学籍档案记录），来分别考察数据元素之间的关系。
                    </div>
                    <div><span style="font-weight: bold;">（1）集合结构</span>
                    </div>
                    <div>数据元素之间除了“属于同一集合”的关系外，别无其他关系。例如，确定一名学生是否为班级成员，只需将班级看做一个集合结构。
                    </div>
                    <div><span style="font-weight: bold;">（2）线性结构</span>
                    </div>
                    <div>数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报到的时间先后顺序进行排列，将组成一个线性结构。
                    </div>
                    <div><span style="font-weight: bold;">（3）树结构</span>
                    </div>
                    <div>数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位组长管理多名组员，从而构成树形结构。
                    </div>
                    <div><span style="font-weight: bold;">（4）图结构或网状结构</span>
                    </div>
                    <div>数据元素之间存在多对多的关系。例如，多位同学之间的朋友关系，任何两位同学都可以是朋友，从而构成图状结构或网状结构。
                    </div>
                    <div><br/>
                    </div>
                    <div>其中集合结构、树结构和图结构都属于非线性结构。
                    </div>
                    <div>
                        线性结构包括线性表（典型的线性结构，如例1.1中的学生基本信息表）、栈和队列（具有特殊限制的线性表，数据操作只能在表的一端或两端进行）、字符串（也是特殊的线性表，其特殊性表现在它的数据元素仅由一个字符组成）、数组（是线性表的推广，它的数据元素是一个线性表）、广义表（也是线性表的推广，它的数据元素是一个线性表，但不同构，即或者是单元素，或者是线性表）。非线性结构包括树（具有多个分支的层次结构）和二叉树（具有两个分支的层次结构）、有向图（一种图结构，边是顶点的有序对）和无向图（另一种图结构，边是顶点的无序对）。这几种逻辑结构可以用一个层次图描述，如图1.4所示。
                    </div>
                    <div style="text-align: center;"><img src="../../images/tu1-4.png"
                                                          style="width: 420px; height: 210px">
                    </div>
                    <div style="text-align: center;"><strong>图1.4 几种逻辑结构层次图</strong>
                    </div>
                    <div><span style="font-size: x-large; font-weight: bold;">2．存储结构</span>
                    </div>
                    <div>
                        数据对象在计算机中的存储表示称为数据的存储结构，也称为物理结构。把数据对象存储到计算机时，通常要求既要存储各数据元素的数据，又要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。数据元素在计算机中有两种基本的存储结构，分别是顺序存储结构和链式存储结构。
                    </div>
                    <div><span style="font-weight: bold;">（1）顺序存储结构</span>
                    </div>
                    <div>顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。
                    </div>
                    <div>对于前面的“学生基本信息表”，假定每个结点（学生记录）占用50个存储单元，数据从0号单元开始由低地址向高地址方向存储，对应的顺序存储结构如表1.2所示。
                    </div>
                    <div style="text-align: center;"><strong>表1.2 顺序存储结构</strong>
                    </div>
                    <div style="text-align: center;"><img src="../../images/biao1-2.png"
                                                          style="width: 550px; height: 150px">
                    </div>
                    <div><span style="font-weight: bold;">（2）链式存储结构</span>
                    </div>
                    <div>
                        顺序存储结构要求所有的元素依次存放在一片连续的存储空间中，而链式存储结构，无需占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。所以链式存储结构通常借助于程序设计语言的指针类型来描述。
                    </div>
                    <div>
                        假定给前面的“学生基本信息表”中的每个结点附加一个“下一个结点地址”，即后继指针字段，用于存放后继结点的首地址，则可得到如表1.3所示的链式存储结构。从表中可以看出，每个结点占用两个连续的存储单元，一个存放结点的信息，另一个存放后继结点的首地址。
                    </div>
                    <div style="text-align: center;"><strong>表1.3 链式存储结构</strong>
                    </div>
                    <div style="text-align: center;"><img src="../../images/biao1-3.png"
                                                          style="width: 550px; height: 150px">
                    </div>
                    <div>为了更清楚地反映链式存储结构，可采用更直观的图示来表示，如“学生基本信息表”的链式存储结构可用如图1.5所示的方式表示。
                    </div>
                    <div style="text-align: center;"><img src="../../images/tu1-5.png"
                                                          style="width: 550px; height: 200px">
                    </div>
                    <div style="text-align: center;"><strong>图1.5 链式存储结构示意图</strong>
                    </div>
                    <div><span id="first1-2-3" style="font-size: xx-large; font-weight: bold;">1.2.3 数据类型和抽象数据类型</span>
                    </div>
                    <div><span style="font-size: x-large; font-weight: bold;">1．数据类型</span>
                    </div>
                    <div>数据类型（Data
                        Type）是高级程序设计语言中的一个基本概念，前面提到过顺序存储结构可以借助程序设计语言的数组类型描述，链式存储结构可以借助指针类型描述，所以数据类型和数据结构的概念密切相关。
                    </div>
                    <div>
                        一方面，在程序设计语言中，每一个数据都属于某种数据类型。类型明显或隐含地规定了数据的取值范围、存储方式以及允许进行的运算，数据类型是一个值的集合和定义在这个值集上的一组操作的总称。例如，C语言中的整型变量，其值集为某个区间上的整数（区间大小依赖于不同的机器），定义在其上的操作为加、减、乘、除和取模等算术运算；而实型变量也有自己的取值范围和相应运算，比如取模运算是不能用于实型变量的。程序设计语言允许用户直接使用的数据类型由具体语言决定，数据类型反映了程序设计语言的数据描述和处理能力。C语言除了提供整型、实型、字符型等基本类型数据外，还允许用户自定义各种类型数据，例如数组、结构体和指针等。
                    </div>
                    <div><span style="font-size: x-large; font-weight: bold;">2．抽象数据类型</span>
                    </div>
                    <div>
                        抽象就是抽取出实际问题的本质。在计算机中使用二进制数来表示数据，在汇编语言中则可给出各种数据的十进制表示，它们是二进制数据的抽象，使用者在编程时可以直接使用，不必考虑实现细节。在高级语言中，则给出更高一级的数据抽象，出现了数据类型，如整型、实型、字符型等，可以进一步利用这些类型构造出线性表、栈、队列、树、图等复杂的抽象数据类型。抽象数据类型（Abstract
                        Data
                        Type，ADT）一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合。抽象数据类型的定义格式如下：
                    </div>
                    <div style="text-align: center;">
			<pre>
<code><ol><li>ADT 抽象数据类型名{</li><li>   数据对象：〈数据对象的定义〉</li><li>   数据关系：〈数据关系的定义〉</li><li>   基本操作：〈基本操作的定义〉</li><li>}ADT 抽象数据类型名</li></ol></code></pre>
                    </div>
                    <div>其中，数据对象和数据关系的定义采用数学符号和自然语言描述，基本操作的定义格式为：
                    </div>
                    <div style="text-align: center;">
			<pre>
<code><ol><li>基本操作名（参数表）</li><li>   初始条件：〈初始条件描述〉</li><li>   操作结果：〈操作结果描述〉</li></ol></code></pre>
                    </div>
                    <div>基本操作有两种参数：赋值参数只为操作提供输入值；引用参数以“&amp;”打头，除可提供输入值外，还将返回操作结果。“初始条件”描述了操作执行之前数据结构和参数应满足的条件，若初始条件为空，则省略。“操作结果”说明了操作正常完成之后，数据结构的变化状况和应返回的结果。
                    </div>
                </div>

                <!--第三节-->
                <div>
                    <div><strong><span id="first1-3"
                                       style="font-size: xxx-large; font-weight: bold;">1.3 抽象数据类型的表示与实现</span></strong>
                    </div>
                    <div>
                        运用抽象数据类型描述数据结构，有助于在设计一个软件系统时，不必首先考虑其中包含的数据对象，以及操作在不同处理器中的表示和实现细节，而是在构成软件系统的每个相对独立的模块上定义一组数据和相应的操作，把这些数据的表示和操作细节留在模块内部解决，在更高的层次上进行软件的分析和设计，从而提高软件的整体性能和利用率。
                    </div>
                    <div>
                        抽象数据类型的概念与面向对象方法的思想是一致的。抽象数据类型独立于具体实现，将数据和操作封装在一起，使得用户程序只能通过抽象数据类型定义的某些操作来访问其中的数据，从而实现了信息隐藏。在C++中，我们可以用类的声明表示抽象数据类型，用类的实现来实现抽象数据类型。因此，C++中实现的类相当于数据的存储结构及其在存储结构上实现的对数据的操作。
                    </div>
                    <div>
                        抽象数据类型和类的概念实际上反映了程序或软件设计的两层抽象：抽象数据类型相当于在概念层（或称为抽象层）上描述问题，而类相当于在实现层上描述问题。此外，C++中的类只是一个由用户定义的普通类型，可用它来定义变量（称为对象或类的实例）。因此，在C++中，最终是通过操作对象来解决实际问题的，所以我们可将该层次看做是应用层。例如，main程序就可看做是用户的应用程序。
                    </div>
                    <div>
                        由此可以看出，最终表示和实现抽象数据类型，最好用面向对象的方法，比如用C++语言的类描述比较方便、有效，但本课程大都在大学低年级开设，用C语言的描述方法更符合学生的实际情况。另外，由于实际问题千变万化，数据模型和算法也形形色色，因此抽象数据类型的设计和实现，就不可能像基本数据类型那样规范和一劳永逸。本书所讨论的数据结构及其算法主要是面向读者的，故采用介于伪码和C语言之间的类C语言作为描述工具。这使得数据结构与算法的描述与讨论简明清晰，不拘泥于C语言的细节，又容易转换成C或C++程序。
                    </div>
                    <div>本书采用的类C语言精选了C语言的一个核心子集，同时做了若干扩充修改，增强了语言的描述功能，以下对其做简要说明。
                    </div>
                    <div><strong>（1）预定义常量及类型：</strong>
                    </div>
                    <div>
                        <strong>
                            <pre>
                                <code>
                                    <ol>
                                        <li><span>//函数结果状态代码</span></li>
                                        <li>#define OK <span>1</span></li>
                                        <li>#define ERROR <span>0</span></li>
                                        <li>#define OVERFLOW -<span>2</span></li>
                                        <li><span>//Status是函数返回值类型，其值是函数结果状态代码。</span></li>
                                        <li>typedef <span>int</span> Status;
                                        </li>
                                    </ol>
                                </code>
                            </pre>

                        </strong>
                        <div><strong>（2）数据结构的表示（存储结构）用类型定义（typedef）描述；</strong>数据元素类型约定为ElemType，由用户在使用该数据类型时自行定义。
                        </div>
                        <div><strong>（3）基本操作的算法都用如下格式的函数来描述：</strong>
                        </div>
                        <div>
                            <strong>
                                <pre>
                                    <code>
                                        <ol>
                                            <li>函数类型 函数名（函数参数表）</li>
                                            <li>{</li>
                                            <li><span>//算法说明</span></li>
                                            <li> 语句序列</li>
                                            <li>}<span>//函数名</span></li>
                                        </ol>
                                    </code>
                                </pre>

                            </strong>
                        </div>
                        <div>当函数返回值为函数结果状态代码时，函数定义为Status类型。为了便于描述算法，除了值调用方式外，增加了C++语言引用调用的参数传递方式。在形参表中，以“&amp;”打头的参数即为引用参数。传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化，但引用使用起来比指针更加方便、高效。
                        </div>
                    </div>
                    <div><strong>（4）内存的动态分配与释放。</strong>
                    </div>
                    <div>使用new和delete动态分配和释放内存空间：
                    </div>
                    <div>
                        <strong>
                            <pre>
                                <code>
                                    <ol>
                                        <li><b>分配空间 指针变量=<span>new</span>数据类型;</b></li>
                                        <li><b>释放空间 delete指针变量;</b></li>
                                    </ol>
                                </code>
                            </pre>

                        </strong>
                    </div>
                    <div><strong>（5）赋值语句：</strong>
                    </div>
                    <div>
                        <strong>
                            <pre>
                                <code>
                                    <ol>
                                        <li>简单赋值 变量名=表达式;</li>
                                        <li>串联赋值 变量名<span>1</span>=变量名<span>2</span>=...=变量名n=表达式;
                                        </li>
                                        <li>成组赋值 (变量名<span>1</span>, ..., 变量名n)=(表达式<span>1</span>, ..., 表达式n);
                                        </li>
                                        <li>结构赋值 结构名<span>1</span>=结构名<span>2</span>;
                                        </li>
                                        <li> 结构名=(值<span>1</span>, 值<span>2</span>,
                                            ..., 值n);
                                        </li>
                                        <li>条件赋值 变量名=条件表达式 ? 表达式T：表达式F;</li>
                                        <li>交换赋值 变量名<span>1</span> &lt;--&gt;变量名<span>2</span>;
                                        </li>
                                    </ol>
                                </code>
                            </pre>

                        </strong>
                    </div>
                    <div><strong>（6）选择语句：</strong>
                    </div>
                    <div>
                        <strong>
                            <pre>
                                <code>
                                    <ol>
                                        <li>条件语句<span>1</span> <span>if</span>
                                            (表达式) 语句;
                                        </li>
                                        <li>条件语句<span>2</span> <span>if</span>
                                            (表达式) 语句;
                                        </li>
                                        <li><span>else</span> 语句;</li>
                                        <li>开关语句 <span>switch</span> (表达式)</li>
                                        <li> {</li>
                                        <li><span>case</span> 值<span>1</span>: 语句序列<span>1</span> ;<span>break</span>;
                                        </li>
                                        <li><span>case</span> 值<span>2</span>: 语句序列<span>2</span> ;<span>break</span>;
                                        </li>
                                        <li> …</li>
                                        <li><span>case</span> 值n: 语句序列n;<span>break</span>;
                                        </li>
                                        <li><span>default</span>: 语句序列n+<span>1</span>;
                                        </li>
                                        <li> }</li>
                                    </ol>
                                </code>
                            </pre>

                        </strong>
                    </div>
                    <div><strong>（7）循环语句：</strong>
                    </div>
                    <div>
                        <strong>
                            <pre>
                                <code>
                                    <ol>
                                        <li><span>for</span>语句 <span>for</span>
                                            (表达式<span>1</span>; 条件; 表达式<span>2</span>) 语句;
                                        </li>
                                        <li><span>while</span>语句 <span>while</span> (条件) 语句;
                                        </li>
                                        <li><span>do</span>-<span>while</span>语句
                                            <span>do</span> {
                                        </li>
                                        <li> 语句序列;</li>
                                        <li> } <span>while</span> (条件);</li>
                                    </ol>
                                </code>
                            </pre>

                        </strong>
                    </div>
                    <div><strong>（8）结束语句：</strong>
                    </div>
                    <div>
                        <strong>
                            <pre>
                                <code>
                                    <ol>
                                        <li>函数结束语句 <span>return</span> 表达式;</li>
                                        <li><span>return</span>;</li>
                                        <li><span>case</span>或循环结束语句 <span>break</span>;
                                        </li>
                                        <li> 异常结束语句 exit (异常代码);</li>
                                    </ol>
                                </code>
                            </pre>

                        </strong>
                    </div>
                    <div><strong>（9）输入输出语句使用C++流式输入输出的形式：</strong>
                    </div>
                    <div>
                        <strong>
                            <pre>
                                <code>
                                    <ol>
                                        <li>输入语句 cin&gt;&gt;变量<span>1</span>&gt;&gt;…&gt;&gt;变量n;</li>
                                        <li>输出语句 cout&lt;&lt;表达式<span>1</span>&lt;&lt;…&lt;&lt;表达式n;
                                        </li>
                                    </ol>
                                </code>
                            </pre>

                        </strong>
                    </div>
                    <div><strong>（10）基本函数：</strong>
                    </div>
                    <div>
                        <strong>
                            <pre>
                                <code>
                                    <ol>
                                        <li>求最大值 Max (表达式<span>1</span>,...,表达式n)</li>
                                        <li>求最小值 Min (表达式<span>1</span>,...,表达式n)</li>
                                    </ol>
                                </code>
                            </pre>

                        </strong>
                    </div>
                    <div>下面以复数为例，给出一个完整的抽象数据类型的定义、表示和实现。
                    </div>
                    <div>（1）定义部分：
                    </div>
                    <div>
                        <strong>
                            <pre>
                                <code>
                                    <ol>
                                        <li><b>ADT Complex {</b></li>
                                        <li><b> 数据对象：D={e1,e2|e1,e2∈R,R是实数集}</b></li>
                                        <li><b> 数据关系：S={&lt;e1,e2&gt;|e1是复数的实部，e2 是复数的虚部}</b></li>
                                        <li><b> 基本操作：</b></li>
                                        <li><b> Creat(&amp;C,x,y)</b></li>
                                        <li><b> 操作结果：构造复数C，其实部和虚部分别被赋以参数x和y的值。</b></li>
                                        <li><b> GetReal(C)</b></li>
                                        <li><b> 初始条件：复数C已存在。</b></li>
                                        <li><b> 操作结果：返回复数C的实部值。</b></li>
                                        <li><b> GetImag(C)</b></li>
                                        <li><b> 初始条件：复数C已存在。</b></li>
                                        <li><b> 操作结果：返回复数C的虚部值。</b></li>
                                        <li><b> Add(C1,C2)</b></li>
                                        <li><b> 初始条件：C1，C2是复数。</b></li>
                                        <li><b> 操作结果：返回两个复数C1和C2的和。</b></li>
                                        <li><b> Sub(C1,C2)</b></li>
                                        <li><b> 初始条件：C1，C2是复数。</b></li>
                                        <li><b> 操作结果：返回两个复数C1和C2的差。</b></li>
                                        <li><b>} ADT Complex</b></li>
                                    </ol>
                                </code>
                            </pre>

                        </strong>
                    </div>
                    <div>
                        在后面的章节中，每定义一个新的数据结构，都先用这种定义方式给出其抽象数据类型的定义，对于数据结构的表示方法，则根据不同的存储结构相应给出，同时用类C语言给出主要操作的实现方法。下面为了让读者对抽象数据类型有一个完整、正确的理解，给出复数的存储表示和相应操作的具体实现过程。
                    </div>
                    <div>（2）表示部分：
                    </div>
                    <strong>
                        <pre>
                          <code>
                                <ol><b>
                                    <li>typedef struct&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                                        //复数类型
                                    </li>
                                    <li>{</li>
                                    <li><span>float</span> Realpart; <span>//实部</span></li>
                                    <li><span>float</span> Imagepart; <span>//虚部</span></li>
                                    <li>}Complex;</li>
                                </b></ol>
                            </code>
                        </pre>
                    </strong>
                    <div><br/>
                    </div>
                    <div>（3）实现部分：
                    </div>
                    <div>
                        <strong>
                            <pre>
                                <code>
                                    <ol>
                                        <li><b><span>void</span> <span>Create</span><span>( &amp;Complex C, <span>float</span> x, <span>float</span> y)</span></b></li>
                                        <li><b>{ <span>//构造一个复数</span></b></li>
                                        <li><b> C.Realpart=x;</b></li>
                                        <li><b> C.Imagepart=y;</b></li>
                                        <li><b>}</b></li>
                                        <li><b><span>float</span> <span>GetReal</span><span>(Complex C)</span></b></li>
                                        <li><b>{ <span>//取复数C=x+yi的实部</span></b></li>
                                        <li><b> <span>return</span> C.Realpart;</b></li>
                                        <li><b>}</b></li>
                                        <li><b><span>float</span> <span>GetImag</span><span>(Complex C)</span></b></li>
                                        <li><b>{ <span>//取复数C=x+yi的虚部</span></b></li>
                                        <li><b> <span>return</span> C.Imagepart;</b></li>
                                        <li><b>}</b></li>
                                        <li><b>Complex <span>Add</span><span>(Complex C1, Complex C2)</span></b></li>
                                        <li><b>{ <span>//求两个复数C1和C2的和sum</span></b></li>
                                        <li><b> Complex sum;</b></li>
                                        <li><b> sum.Realpart=C1.Realpart+C2.Realpart;</b></li>
                                        <li><b> sum.Imagepart=C1.Imagepart+C2.Imagepart;</b></li>
                                        <li><b> <span>return</span> sum;</b></li>
                                        <li><b>}</b></li>
                                        <li><b>Complex <span>Sub</span><span>(Complex C1, Complex C2)</span></b></li>
                                        <li><b>{ <span>//求两个复数C1和C2的差difference</span></b></li>
                                        <li><b> Complex difference;</b></li>
                                        <li><b> difference.Realpart=C1.Realpart-C2.Realpart;</b></li>
                                        <li><b> difference.Imagepart=C1.Imagepart-C2.Imagepart;</b></li>
                                        <li><b> <span>return</span> difference;</b></li>
                                        <li><b>}</b></li>
                                    </ol>
                                </code>
                            </pre>

                        </strong>
                    </div>
                    <div>
                        这样定义之后，就可以在主程序中通过调用Create函数构造一个复数，调用Add或Sub函数实现复数的加法或减法运算，用户可以像使用整数类型那样使用复数类型了。通过上述实例，读者可以对抽象数据类型的概念有更加深刻的理解。
                    </div>
                </div>

                <!--第四节-->
                <div>
                    <div><span id="first1-4"
                               style="font-size: xxx-large; font-weight: bold;"><strong>1.4 算法和算法分析</strong></span>
                    </div>
                    <div>
                        数据结构与算法之间存在着本质联系，在某一类型数据结构上，总要涉及其上施加的运算，而只有通过对所定义运算的研究，才能清楚理解数据结构的定义和作用；在涉及运算时，总要联系到该算法处理的对象和结果的数据。在“数据结构”中，将遇到大量的算法问题，因为算法联系着数据在计算过程中的组织方式，为了描述实现某种操作，常常需要设计算法，因而算法是研究数据结构的重要途径。
                    </div>
                    <div><span id="first1-4-1" style="font-size: 24pt"><strong>1.4.1 算法的定义及特性</strong></span>
                    </div>
                    <div>算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列。一个算法必须满足以下五个重要特性。
                    </div>
                    <div>（1）<strong>有穷性。</strong>一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。
                    </div>
                    <div>（2）<strong>确定性。</strong>对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，使算法的执行者或阅读者都能明确其含义及如何执行。
                    </div>
                    <div>（3）<strong>可行性。</strong>算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。
                    </div>
                    <div>（4）<strong>输入。</strong>一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。
                    </div>
                    <div>（5）<strong>输出。</strong>一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。
                    </div>
                    <div><span id="first1-4-2" style="font-size: 24pt"><strong>1.4.2 评价算法优劣的基本标准</strong></span>
                    </div>
                    <div>一个算法的优劣应该从以下几方面来评价。
                    </div>
                    <div>（1）<strong>正确性。</strong>在合理的数据输入下，能够在有限的运行时间内得到正确的结果。
                    </div>
                    <div>（2）<strong>可读性。</strong>一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。
                    </div>
                    <div>（3）<strong>健壮性。</strong>当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。
                    </div>
                    <div>（4）<strong>高效性。</strong>高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。
                    </div>
                    <div><span id="first1-4-3" style="font-size: 24pt"><strong>1.4.3 算法的时间复杂度</strong></span>
                    </div>
                    <div>算法效率分析的目的是看算法实际是否可行，并在同一问题存在多个算法时，可进行时间和空间性能上的比较，以便从中挑选出较优算法。
                    </div>
                    <div>
                        衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。事后统计法需要先将算法实现，然后测算其时间和空间开销。这种方法的缺陷很显然，一是必须把算法转换成可执行的程序，二是时空开销的测算结果依赖于计算机的软硬件等环境因素，这容易掩盖算法本身的优劣。所以我们通常采用事前分析估算法，通过计算算法的渐近复杂度来衡量算法的效率。
                    </div>
                    <div>
                        1．问题规模和语句频度不考虑计算机的软硬件等环境因素，影响算法时间代价的最主要因素是问题规模。问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。问题规模n对不同的问题含义不同，例如，在排序运算中n为参加排序的记录数，在矩阵运算中n为矩阵的阶数，在多项式运算中n为多项式的项数，在集合运算中n为集合中元素的个数，在树的有关运算中n为树的结点个数，在图的有关运算中n为图的顶点数或边数。显然，n越大算法的执行时间越长。
                    </div>
                    <div>一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。
                    </div>
                    <div>一条语句的重复执行次数称作<span style="font-weight: bold;">语句频度（Frequency Count）</span>。
                    </div>
                    <div>
                        由于语句的执行要由源程序经编译程序翻译成目标代码，目标代码经装配再执行，因此语句执行一次实际所需的具体时间是与机器的软、硬件环境（如机器速度、编译程序质量等）密切相关的。所以，所谓的算法分析并非精确统计算法实际执行所需时间，而是针对算法中语句的执行次数做出估计，从中得到算法执行时间的信息。
                    </div>
                    <div>设每条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量。
                    </div>
                    <div><strong>【例1.4】</strong> 求两个n阶矩阵的乘积算法。
                    </div>
                    <div>
                        <code>
                            <ol>
                                <li><span>for</span>(i=<span>1</span>;i&lt;=n;i++) <span>//频度为n+1</span></li>
                                <li><span style="font-weight: bold;">   <span>for</span>(j=<span>1</span>;j&lt;=n;j++)                                         <span>//频度为n*(n+1)</span></span>
                                </li>
                                <li><span style="font-weight: bold;">   {</span></li>
                                <li><span style="font-weight: bold;">       c[i][j]=<span>0</span>;                                            <span>//频度为n2</span></span>
                                </li>
                                <li><span style="font-weight: bold;">       <span>for</span>(k=<span>1</span>;k&lt;=n;k++)                                     <span>//频度为n2 * (n+1)</span></span>
                                </li>
                                <li><span style="font-weight: bold;">       c[i][j]=c[i][j]+a[i][k]*b[k][j];                      <span>//频度为n3</span></span>
                                </li>
                                <li><span style="font-weight: bold;">   }</span></li>
                            </ol>
                        </code>
                    </div>
                    <div>该算法中所有语句频度之和，是矩阵阶数n的函数，用f(n)表示之。换句话说，上例算法的执行时间与f(n)成正比。
                    </div>
                    <div style="text-align: center;"><span style="font-weight: bold; ">f(n)=2n3+3n2+2n+1</span>
                    </div>
                    <div>2．算法的时间复杂度定义
                    </div>
                    <div>
                        对于例1.4这种较简单的算法，可以直接计算出算法中所有语句的频度，但对于稍微复杂一些的算法，则通常是比较困难的，即便能够给出，也可能是个非常复杂的函数。因此，为了客观地反映一个算法的执行时间，可以只用算法中的“基本语句”的执行次数来度量算法的工作量。所谓“基本语句”指的是算法中重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大。通常，算法的执行时间是随问题规模增长而增长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。这种情况下，我们只需要考虑当问题规模充分大时，算法中基本语句的执行次数在渐近意义下的阶。如例1.4矩阵的乘积算法，当n趋向无穷大时，显然有
                    </div>
                    <div style="text-align: center;"><img src="../../images/img1-4-1.png"/>
                    </div>
                    <div>即当n充分大时，f(n)和n3之比是一个不等于零的常数。即f(n)和n3是同阶的，或者说f(n)和n3的数量级（Order of
                        Magnitude）相同。在这里，我们用“O”来表示数量级，记作T(n)=O(f(n))=O(n3)。由此我们可以给出下述算法时间复杂度的定义。
                    </div>
                    <div>一般情况下，算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记作
                    </div>
                    <div style="text-align: center;"><span style="font-weight: bold; ">T(n)=O(f(n))</span>
                    </div>
                    <div>它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称做算法的渐近时间复杂度，简称<span style="font-weight: bold;">时间复杂度（Time Complexity）</span>。
                    </div>
                    <div>数学符号“O”的严格定义为：
                    </div>
                    <div>若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n)=O(f(n))表示存在正的常数C和n0，使得当n≥n0时都满足0≤T(n)≤Cf(n)。
                    </div>
                    <div>该定义说明了函数T(n)和f(n)具有相同的增长趋势，并且T(n)的增长至多趋向于函数f(n)的增长。符号“O”用来描述增长率的上限，它表示当问题规模n&gt;n0时，算法的执行时间不会超过f(n)，其直观的含义如图1.6所示。
                    </div>
                    <div style="text-align: center;">[插图]
                    </div>
                    <div style="text-align: center;">图1.6&nbsp;符号“O”的直观含义
                    </div>
                    <div>3．算法的时间复杂度分析举例
                    </div>
                    <div>
                        分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语句，计算基本语句的频度得到问题规模n的某个函数f(n)，取其数量级用符号“O”表示即可。具体计算数量级时，可以遵循以下定理。
                    </div>
                    <div><strong>定理1.1若f(n)=amnm+am-1nm-1+…+a1n+a0是一个m次多项式，则T(n)=O(nm)。</strong>
                    </div>
                    <div>定理1.1说明，在计算算法时间复杂度时，可以忽略所有低次幂项和最高次幂的系数，这样可以简化算法分析，也体现出了增长率的含义。
                    </div>
                    <div>若算法可用递归方法描述，则算法的时间复杂度通常可使用递归方程表示，此时将涉及递归方程求解问题。有关递归算法的时间复杂度分析方法将在第3章给出。
                    </div>
                    <div>下面举例说明如何求非递归算法的时间复杂度。
                    </div>
                    <div><strong>【例1.5】</strong> 常量阶示例。
                    </div>
                    <div>
                        <code>
                            <ol>
                                <li><b>{x++;s=<span>0</span>;}</b></li>
                            </ol>
                        </code>
                    </div>
                    <div>两条语句频度均为1，算法的执行时间是一个与问题规模n无关的常数，所以算法的时间复杂度为T(n)=O(1)，称为常量阶。
                    </div>
                    <div>实际上，如果算法的执行时间不随问题规模n的增加而增长，算法中语句频度就是某个常数。即使这个常数再大，算法的时间复杂度都是O(1)。例如，上面的程序作如下改动：
                    </div>
                    <div>
                        <code>
                            <ol>
                                <li><span>for</span>(i=<span>0</span>;i&lt;<span>10000</span>;i++){x++;s=<span>0</span>;}
                                </li>
                            </ol>
                        </code>
                    </div>
                    <div>算法的时间复杂度仍然为O(1)。
                    </div>
                    <div><strong>【例1.6】</strong> 线性阶示例。
                    </div>
                    <div>
                        <code>
                            <ol>
                                <li><span>for</span>(i=<span>0</span>;i&lt;n;i++){x++;s=<span>0</span>;}
                                </li>
                            </ol>
                        </code>
                    </div>
                    <div>循环体内两条基本语句的频度均为f(n)=n，所以算法的时间复杂度为T(n)=O(n)，称为线性阶。
                    </div>
                    <div><strong>【例1.7】</strong> 平方阶示例。
                    </div>
                    <div>
                        <code>
                            <ol>
                                <li>(<span>1</span>) x=<span>0</span>;y=<span>0</span>;
                                </li>
                                <li>(<span>2</span>) <span>for</span>(k=<span>1</span>;k&lt;=n;k++)
                                </li>
                                <li>(<span>3</span>) x++;
                                </li>
                                <li>(<span>4</span>) <span>for</span>(i=<span>1</span>;i&lt;=n;i++)
                                </li>
                                <li>(<span>5</span>) <span>for</span>(j=<span>1</span>;j&lt;=n;j++)
                                </li>
                                <li>(<span>6</span>) y++;
                                </li>
                            </ol>
                        </code>
                    </div>
                    <div>
                        对循环语句只需考虑循环体中语句的执行次数，以上程序段中频度最大的语句是（6），其频度为f(n)=n2，所以该算法的时间复杂度为T(n)=O(n2)，称为平方阶。多数情况下，当有若干个循环语句时，算法的时间复杂度是由最深层循环内的基本语句的频度f(n)决定的。
                    </div>
                    <div><strong>【例1.8】 </strong>立方阶示例。
                    </div>
                    <div>

                        <code>
                            <ol>
                                <li>(<span>1</span>) x=<span>1</span>;
                                </li>
                                <li>(<span>2</span>) <span>for</span>(i=<span>1</span>;i&lt;=n;i++)
                                </li>
                                <li>(<span>3</span>) <span>for</span>(j=<span>1</span>;j&lt;=i;j++)
                                </li>
                                <li>(<span>4</span>) <span>for</span>(k=<span>1</span>;k&lt;=j;k++)
                                </li>
                                <li>(<span>5</span>) x++;
                                </li>
                            </ol>
                        </code>
                    </div>
                    <div>显见，该程序段中频度最大的语句是（5），这条最深层循环内的基本语句的频度，依赖于各层循环变量的取值，由内向外可分析出语句（5）的执行次数为：
                    </div>
                    <div style="text-align: center;"><img src="../../images/img1-4-2.png"/>
                    </div>
                    <div>则该算法的时间复杂度为T(n)=O(n3)，称为立方阶。
                    </div>
                    <div><strong>【例1.9】</strong> 对数阶示例。
                    </div>
                    <div>

                        <code>
                            <ol>
                                <li><span>for</span>(i=<span>1</span>;i&lt;=n;i=i*<span>2</span>){x++;s=<span>0</span>;}
                                </li>
                            </ol>
                        </code>
                    </div>
                    <div>设循环体内两条基本语句的频度为f(n)，则有2f(n)≤n，f(n)≤log2n，所以算法的时间复杂度为T(n)=O(log2n)，称为对数阶。
                    </div>
                    <div>
                        常见的时间复杂度按数量级递增排列依次为：常量阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……、k次方阶O(nk)、指数阶O(2n)等。
                    </div>
                    <div>
                        不同数量级的时间复杂度性状如图1.7所示。一般情况下，随着n的增大，T(n)的增长较慢的算法为较优的算法。显然，时间复杂度为指数阶O(2n)的算法效率极低，当n值稍大时就无法应用。应该尽可能选择使用多项式阶O(nk)的算法，而避免使用指数阶的算法。
                    </div>
                    <div style="text-align: center;">[插图]
                    </div>
                    <div style="text-align: center;">图1.7 常见函数的增长率
                    </div>
                    <div>4．最好、最坏和平均时间复杂度
                    </div>
                    <div>对于某些问题的算法，其基本语句的频度不仅仅与问题的规模相关，还依赖于其他因素。在此仅举一例说明之。
                    </div>
                    <div><strong>【例1.10】</strong> 在一维数组a中顺序查找某个值等于e的元素，并返回其所在位置。
                    </div>
                    <div>
                        <code>
                            <ol>
                                <li><b>(<span>1</span>) <span>for</span>(i=<span>0</span>;i&lt;n;i++)</b>
                                </li>
                                <li><b>(<span>2</span>) <span>if</span>(a[i]==e)
                                    <span>return</span> i+<span>1</span>;</b></li>
                                <li><b>(<span>3</span>) <span>return</span>
                                    <span>0</span>;</b></li>
                            </ol>
                        </code>
                    </div>
                    <div>
                        容易看出，此算法中语句（2）的频度不仅与问题规模n有关，还与输入实例中数组a[i]的各元素值及e的取值有关。假设在数组a[i]中必定存在值等于e的元素，则查找必定成功，且for循环内的语句的频度将随被找到的元素在数组中出现的位置不同而不同，最好情况是，每次要找的值与e相同的元素恰好就是数组中的第一个元素，则不论数组的规模多大，语句（2）的频度f(n)=1，最坏情况是，每次待查找的都是数组中最后一个元素，则语句（2）的频度f(n)=n。而对于一个算法来说，需要考虑各种可能出现的情况，以及每一种情况出现的概率，一般情况下，可假设待查找的元素在数组中所有位置上出现的可能性均相同，则可取语句（2）的频度在最好情况与最坏情况下的平均值，即f(n)=n/2，作为它的度量。
                    </div>
                    <div>此例说明，算法的时间复杂度不仅与问题的规模有关，还与问题的其他因素有关。再如某些排序的算法，其执行时间与待排序记录的初始状态有关。因此，有时会对算法有最好、最坏以及平均时间复杂度的评价。
                    </div>
                    <div>
                        称算法在最好情况下的时间复杂度为最好时间复杂度，指的是算法计算量可能达到的最小值；称算法在最坏情况下的时间复杂度为最坏时间复杂度，指的是算法计算量可能达到的最大值；算法的平均时间复杂度是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。
                    </div>
                    <div>
                        对算法时间复杂度的度量，人们更关心的是最坏情况下和平均情况下的时间复杂度。然而在很多情况下，算法的平均时间复杂度难于确定。因此，通常只讨论算法在最坏情况下的时间复杂度，即分析在最坏情况下，算法执行时间的上界。在本书后面内容中讨论的时间复杂度，除特别指明外，均指最坏情况下的时间复杂度。
                    </div>
                    <div><span id="first1-4-4" style="font-size: 24pt"><strong>1.4.4 算法的空间复杂度</strong></span>
                    </div>
                    <div>关于算法的存储空间需求，类似于算法的时间复杂度，我们采用渐近空间复杂度（Space Complexity）作为算法所需存储空间的量度，简称空间复杂度，它也是问题规模n的函数，记作：
                    </div>
                    <div style="text-align: center;"><strong>S(n)=O(f (n))</strong>
                    </div>
                    <div>
                        一般情况下，一个程序在机器上执行时，除了需要寄存本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的辅助存储空间。其中，对于输入数据所占的具体存储量取决于问题本身，与算法无关，这样只需分析该算法在实现时所需要的辅助空间就可以了。若算法执行时所需要的辅助空间相对于输入数据量而言是个常数，则称这个算法为原地工作，辅助空间为O(1)，本节中前面的示例都是如此。有的算法需要占用临时的工作单元数与问题规模n有关，如第8章介绍的归并排序算法就属于这种情况。
                    </div>
                    <div>下面举一简单示例说明如何求算法的空间复杂度。
                    </div>
                    <div><strong>【例1.11】</strong> 数组逆序，将一维数组a中的n个数逆序存放到原数组中。
                    </div>
                    <div>【算法1】
                    </div>
                    <div>

                        <code>
                            <ol>
                                <li><span>for</span>(i=<span>0</span>;i&lt;n/<span>2</span>;i++)
                                </li>
                                <li><b>{ t=a[i];</b></li>
                                <li><b> a[i]=a[n-i-<span>1</span>];</b></li>
                                <li><b> a[n-i-<span>1</span>]=t;</b></li>
                                <li><b>}</b></li>
                            </ol>
                        </code>
                    </div>
                    <div>【算法2】
                    </div>
                    <div>

                        <code>
                            <ol>
                                <li><span>for</span>(i=<span>0</span>;i&lt;n;i++)
                                </li>
                                <li> b[i]=a[n-i-<span>1</span>];</li>
                                <li><span>for</span>(i=<span>0</span>;i&lt;n;i++)
                                </li>
                                <li> a[i]=b[i];</li>
                            </ol>
                        </code>
                    </div>
                    <div>算法1仅需要另外借助一个变量t，与问题规模n大小无关，所以其空间复杂度为O(1)。
                    </div>
                    <div>算法2需要另外借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)。
                    </div>
                    <div>
                        对于一个算法，其时间复杂度和空间复杂度往往是相互影响的，当追求一个较好的时间复杂度时，可能会导致占用较多的存储空间，即可能会使空间复杂度的性能变差，反之亦然。不过，通常情况下，鉴于运算空间较为充足，人们都以算法的时间复杂度作为算法优劣的衡量指标。
                    </div>
                </div>

                <!--小结-->
                <div>
                    <div><span id="first1-5" style="font-size: xxx-large; font-weight: bold;">1.5 小结</span>
                    </div>
                    <div>本章介绍了数据结构的基本概念和术语，以及算法和算法时间复杂度的分析方法。主要内容如下。
                    </div>
                    <div>（1）数据结构是一门研究非数值计算程序设计中操作对象，以及这些对象之间的关系和操作的学科。
                    </div>
                    <div>（2）数据结构包括两个方面的内容：数据的逻辑结构和存储结构。同一逻辑结构采用不同的存储方法，可以得到不同的存储结构。① 逻辑结构是从具体问题抽象出来的数学模型，从逻辑关系上描述数据，它与数据的存储无关。根据数据元素之间关系的不同特性，通常有四类基本逻辑结构：集合结构、线性结构、树形结构和图状结构。② 存储结构是逻辑结构在计算机中的存储表示，有两类存储结构：顺序存储结构和链式存储结构。
                    </div>
                    <div>（3）抽象数据类型是指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合，以及对数据对象的基本操作的集合。
                    </div>
                    <div>（4）算法是为了解决某类问题而规定的一个有限长的操作序列。算法具有五个特性：有穷性、确定性、可行性、输入和输出。一个算法的优劣应该从以下四方面来评价：正确性、可读性、健壮性和高效性。
                    </div>
                    <div>（5）算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，以考察算法的时间和空间效率。一般情况下，鉴于运算空间较为充足，故将算法的时间复杂度作为分析的重点。算法执行时间的数量级称为算法的渐近时间复杂度，T(n)=O(f(n))，它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，简称时间复杂度。
                    </div>
                    <div>学完本章后，要求掌握数据结构相关的基本概念，包括数据、数据元素、数据项、数据对象、数据结构、逻辑结构、存储结构等；重点掌握数据结构所含两个层次的具体含义及其相互关系；了解抽象数据类型的定义、表示与实现方法；了解算法的特性和评价标准；重点掌握算法时间复杂度的分析方法。
                    </div>
                </div>

            </el-main>
        </el-container>
    </div>
</div>

<script>
    new Vue({
        el: '#app',
        methods: {
            handleOpen(key, keyPath) {
                console.log(key, keyPath);
            },
            handleClose(key, keyPath) {
                console.log(key, keyPath);
            }
        }
    })
</script>


</body>
</html>